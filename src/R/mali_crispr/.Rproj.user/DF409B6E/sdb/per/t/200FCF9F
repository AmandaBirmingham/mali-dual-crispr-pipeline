{
    "collab_server" : "",
    "contents" : "##################### INPUT PARAMETERS #########################################\nproject<-\"A549_CV4_3-14-21-28_NA_combined_simple-null-w-lfdr\" #project name - will be used in naming output files\ninput_filename<-\"../A549_CV4_counts_w_everything.txt\"\ntime<-c(3,14,21,28) #time points, in days\nab0<-c(-19.,-18.5,-18.5,-19.,-19.,-19.,-19.,-19.) #abundance threshold\nniter<-1000\n################################################################################\n\nlibrary(MASS)\nlibrary(locfdr)\nlibrary(qvalue)\n\n\nVar<-function(x) mean(x^2)-mean(x)^2 #scalar version\nvVar<-function(x) apply(x^2,1,mean)-apply(x,1,mean)^2 #vector version\n\nCov<-function(x,y) mean(x*y)-mean(x)*mean(y)\nvCov<-function(x,y) apply(t(x)*y,2,mean)-apply(x,1,mean)*mean(y) #x is a matrix and y is a vector\n\nsqrtsum<-function(y) sqrt(sum(y^2))\n\nfit_ac_fc<-function(x1,ab1,x2,ab2) { #badx is TRUE when x-value is bad\n\n   er_ac<-1\n   l<-0\n   nx<-nrow(x1)\n   good1<-t(t(x1)>ab1)\n   good2<-t(t(x2)>ab2)\n   useless1<-apply(good1,1,sum)<2\n   useless2<-apply(good2,1,sum)<2\n   good1[useless1,]<-FALSE #remove singletons\n   good2[useless2,]<-FALSE #remove singletons\n   \n#  allbad<-!(apply(good1[,1:2],1,sum)==2 | apply(good1[,(nt-1):nt],1,sum)==2) | !(apply(good2[,1:2],1,sum)==2 | apply(good2[,(nt-1):nt],1,sum)==2)\n   allbad<-apply(good1,1,sum)<2 & apply(good2,1,sum)<2 #in this case I have nothing to use in either experiment\n\n   lambda1<-rep(0,nt)\n   lambda2<-rep(0,nt)\n   ac1<-x1[,1] #just a guess\n   ac2<-x2[,1] #just a guess\n#  ac1<-rep(-Inf,nx) #underrepresented constructs will get zero abundance\n#  ac2<-rep(-Inf,nx) #underrepresented constructs will get zero abundance\n   fc<-rep(0,nx)\n\n   for (i in 1:nx) {\n      if (allbad[i]) next #from now on there is at least one good experiment\n      f1<-0\n      f2<-0\n      v1<-0\n      v2<-0\n      g1<-good1[i,]\n      if (sum(g1)>1) { #it's a good experiment\n         mx1<-mean(x1[i,g1])\n         mt1<-mean(time[g1])\n         v1<-Var(time[g1])\n         f1<-Cov(x1[i,g1],time[g1])\n      }\n  \n      g2<-good2[i,]\n      if (sum(g2)>1) { #it's a good experiment\n         mx2<-mean(x2[i,g2])\n         mt2<-mean(time[g2])\n         v2<-Var(time[g2])\n         f2<-Cov(x2[i,g2],time[g2])\n      }\n      fc[i]<-(f1+f2)/(v1+v2) #the combined fitness from replicate 1+2\n      #fc remains defined up to an additive constant\n\n      if (sum(g1)>1) {\n         ac1[i]<-mx1-fc[i]*mt1\n      }\n      if (sum(g2)>1) {\n         ac2[i]<-mx2-fc[i]*mt2\n      }\n   }\n   alpha<- -log2(sum(2^ac1))\n   ac1<-ac1+alpha #enforce normalization at time=0, sum(2^ac)=1\n   alpha<- -log2(sum(2^ac2))\n   ac2<-ac2+alpha #enforce normalization at time=0, sum(2^ac)=1\n\n   for (i in 1:nt) {\n      lambda1[i]<- -log2(sum(2^(ac1+fc*time[i])))\n      lambda2[i]<- -log2(sum(2^(ac2+fc*time[i])))\n   } #these are initial estimates of lambda(t)\n\n   xfit1<-x1 #for size\n   for (j in 1:nt) {\n      xfit1[,j]<-ac1+fc*time[j]+lambda1[j]\n   }\n   xfit2<-x2 #for size\n   for (j in 1:nt) {\n      xfit2[,j]<-ac2+fc*time[j]+lambda2[j]\n   }\n\n   sdfc<-rep(0.1,nx) #standard error of fc\n   tstat<-rep(0,nx)\n   df<-rep(0,nx)\n   p_t<-rep(1,nx)\n#  sefc<-apply(xfit-x,1,sqrtsum)/sqrtsum(time)\n   for (i in 1:nx) {\n      if (allbad[i]) next\n      \n      g1<-good1[i,]\n      g2<-good2[i,]\n      df[i]<-sum(g1)+sum(g2)-2\n#      sefc[i]<-sqrtsum( c(xfit1[i,good1[i,]],xfit2[i,good2[i,]]) - c(x1[i,good1[i,]],x2[i,good2[i,]]) ) /sqrtsum( c(time[good1[i,]],time[good2[i,]]) - mean(c(time[good1[i,]],time[good2[i,]])) ) /sqrt(df[i])\n      sdfc[i]<-sqrtsum( c(xfit1[i,g1],xfit2[i,g2]) - c(x1[i,g1],x2[i,g2]) ) /sqrtsum( c(time[g1],time[g2]) - mean(c(time[g1],time[g2])) )\n   }\n#what is median sd? \n   has_sd<-df>0\n   median_sd<-median(sdfc[has_sd])\n   sdfc[!has_sd]<-median_sd #just so it isn't 0\n   \n   \n   for (i in 1:nx) {\n      if (!has_sd[i]) next\n      tstat[i]<-fc[i]/(sdfc[i]/sqrt(df[i]))\n      p_t[i]<-2*pt(-abs(tstat[i]),df=df[i]) #raw p-values from t-test\n   }\n   lfdr_fc<-rep(1,nx)\n   l<-lfdr(p_t[has_sd],pi0.method=\"bootstrap\")\n   lfdr_fc[has_sd]<-l\n\n\n#  ptraw<-2*pt(-abs(tstat),df=df)\n#  lfdrt<-lfdr(ptraw,pi0.method=\"bootstrap\")\n\n   vl<-list(ac1,ac2,fc,sdfc,p_t,lfdr_fc,df,allbad)\n   return(vl)\n}\n\nplot_fit<-function(x1,ac1,fc1,ab1,x2,ac2,fc2,ab2,minfc=0.10) {\n\n   nx<-nrow(x1)\n   maxt<-time[nt]+3\n   plot_lambda1<-rep(0,maxt)\n   plot_lambda2<-rep(0,maxt)\n\n   good1<-t(t(x1)>ab1)\n   good2<-t(t(x2)>ab2)\n   allbad<-apply(good1,1,sum)<2 & apply(good2,1,sum)<2 #in this case I have nothing to use in either experiment\n\n   for (i in 1:maxt) plot_lambda1[i]<- -log2(sum(2^(ac1+fc1*i)))\n   for (i in 1:maxt) plot_lambda2[i]<- -log2(sum(2^(ac2+fc2*i)))\n   \n   rge<-range(c(x1,x2))\n   for (i in 1:nx) {\n      if (allbad[i]) next\n      if (abs(fc1[i])<minfc & abs(fc2[i])<minfc) next\n      pch<-rep(1,nt)\n      pch[good1[i,]]<-16 #circle\n      plot(time,x1[i,],ylim=rge,pch=pch,cex=1.2,main=pA_pB[i],xlab=\"time\",ylab=expression(paste(log[2],\" relative frequency\")))\n      yfit<-ac1[i]+fc1[i]*(1:maxt)+plot_lambda1\n      lines(1:maxt,yfit)\n\n      pch<-rep(1,nt)\n      pch[good2[i,]]<-16 \n      points(time,x2[i,],pch=pch,cex=1.2,col=\"blue\")\n      yfit<-ac2[i]+fc2[i]*(1:maxt)+plot_lambda2\n      lines(1:maxt,yfit,col=\"blue\")\n   }\n}\n\n#iterative robust least squares\nirls<-function(fc,w0,probes,ag=2,tol=1e-3,maxiter=30) {\n# w0 is the physical goodness of constructs. It is not subject to change.\n# It is used to modify w, to silence bad constructs \n\n   expressed_utri<-upper.tri(fc) & w0>0\n   n<-dim(fc)[1]\n   w<-matrix(1,nrow=n,ncol=n) #initial weights\n   diag(w)<-0\n   fij<-matrix(0,nrow=n,ncol=n) #initial weights\n   eij<-matrix(0,nrow=n,ncol=n) #initial weights\n   b<-rep(0,n) #rhs\n\n   #iteration step 0\n   w<-w*w0\n   A<-w\n   for (i in 1:n) {\n      b[i]<-sum(fc[,i]*w[,i])\n      A[i,i]<-sum(w[,i])+small\n   }\n   y<-solve(A,b)\n   names(y)<-probes\n   for (i in 1:(n-1)) {\n      for (j in (i+1):n) {\n         fij[i,j]<-y[i]+y[j]\n      }\n   }\n   fij<-fij+t(fij)\n   eij<-fc-fij #residuals\n\n   l<-1 #counter\n   rel<-1\n   while (rel > tol & l < maxiter) {#iterate until tol is reached or maxit\n      s<-sd(eij[expressed_utri]) #calculate sd only from expressed constructs\n      yold<-y\n\n      w<-(1-eij^2/(ag*s)^2)^2 #something like Tukey's biweight\n      w[abs(eij)>(ag*s)]<-0\n      diag(w)<-0\n\n      w<-w*w0\n\n      A<-w\n      for (i in 1:n) {\n         b[i]<-sum(fc[,i]*w[,i])\n         A[i,i]<-sum(w[,i])+small\n      }\n      y<-solve(A,b)\n      names(y)<-probes\n      fij<-matrix(0,nrow=n,ncol=n) #initial weights\n      for (i in 1:(n-1)) {\n         for (j in (i+1):n) {\n            fij[i,j]<-y[i]+y[j]\n         }\n      }\n      fij<-fij+t(fij)\n      eij<-fc-fij #residuals\n\n      rel<-sqrt(sum((y-yold)^2)/max(1,sum(yold^2))) #relative error\n      cat(l,sqrtsum(yold),sqrtsum(y-yold),\"\\n\")\n      l<-l+1\n   }\n   vl<-list(y, fij, eij)\n   return(vl)\n}\n\nplotOverlappingHist <- function(a, b, colors=c(\"gray70\",\"gray20\",\"gray50\"), breaks=NULL, xlim=NULL, ylim=NULL, xlab=NULL,ylab=NULL, main=NULL){\n   ahist=NULL\n   bhist=NULL\n   if(!(is.null(breaks))){\n      ahist=hist(a,breaks=breaks,plot=FALSE)\n      bhist=hist(b,breaks=breaks,plot=FALSE)\n   } else {\n      ahist=hist(a,plot=FALSE)\n      bhist=hist(b,plot=FALSE)\n      dist = ahist$breaks[2]-ahist$breaks[1]\n      breaks = seq(min(ahist$breaks,bhist$breaks),max(ahist$breaks,bhist$breaks),dist)\n      ahist=hist(a,breaks=breaks,plot=FALSE)\n      bhist=hist(b,breaks=breaks,plot=FALSE)\n   }\n \n   if(is.null(xlim)){\n      xlim = c(min(ahist$breaks,bhist$breaks),max(ahist$breaks,bhist$breaks))\n   }\n \n   if(is.null(ylim)){\n      ylim = c(0,max(ahist$counts,bhist$counts))\n   }\n \n   overlap = ahist\n   for(i in 1:length(overlap$counts)){\n      if(ahist$counts[i] > 0 & bhist$counts[i] > 0){\n         overlap$counts[i] = min(ahist$counts[i],bhist$counts[i])\n      } else {\n         overlap$counts[i] = 0\n      }\n   }\n\n   plot(ahist, xlim=xlim, ylim=ylim, col=colors[1], border=colors[1],xlab=xlab,ylab=ylab,main=main)\n   plot(bhist, xlim=xlim, ylim=ylim, col=colors[2], border=colors[2], add=TRUE)\n   plot(overlap, xlim=xlim, ylim=ylim, col=colors[3], border=colors[3], add=TRUE)\n}\n\nplot_scatterplots<-function() {\n\n#now plot fitted value scatterplots\nfit_x1<-matrix(0,nrow=nn,ncol=nt)\nfit_x2<-matrix(0,nrow=nn,ncol=nt)\nfor (j in 1:nt) {\n   fit_x1[,j]<-2^(a1+fc*time[j])\n   fit_x2[,j]<-2^(a2+fc*time[j])\n}\nfit_x1[bad1,]<-0 #remove missing constructs\nfit_x2[bad2,]<-0\nab1<-apply(fit_x1,2,sum)\nab2<-apply(fit_x2,2,sum)\nfit_x1<-t(t(fit_x1)/ab1) #take ratio to get fitted x_c values\nfit_x2<-t(t(fit_x2)/ab2)\nfit_x1[!bad1,]<-log2(fit_x1[!bad1,])\nfit_x2[!bad2,]<-log2(fit_x2[!bad2,])\nfit_x1[bad1,]<-0 #remove missing constructs\nfit_x2[bad2,]<-0\n\n\n#plot experimental values\nfor (i in 2:nt) {\n   smoothScatter(x1[!bad1,c(1,i)],xlim=c(-17,-11),ylim=c(-17,-11),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,xlab=paste(\"log2 frequency, d\",time[1],sep=\"\"),ylab=paste(\"log2 frequency, d\",time[i],sep=\"\"),main=\"experimental log2 frequencies, replicate 1\")\n   abline(0,1,col=\"#000066\")\n   a<-(x1[!bad1,i]+x1[!bad1,1])/2\n   m<-(x1[!bad1,i]-x1[!bad1,1])\n   smoothScatter(a,m,xlim=c(-17,-11),ylim=c(-10,10),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,main=paste(\"experimental log2 frequencies, replicate 1, d\",time[1],\"-d\",time[i],sep=\"\"))\n   abline(h=0,col=\"#000066\")\n   yl<-lowess(a,m,f=0.2)\n   lines(yl,col=\"red\")\n}\nfor (i in 2:nt) {\n   smoothScatter(x2[!bad2,c(1,i)],xlim=c(-17,-11),ylim=c(-17,-11),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,xlab=paste(\"log2 frequency, d\",time[1],sep=\"\"),ylab=paste(\"log2 frequency, d\",time[i],sep=\"\"),main=\"experimental log2 frequencies, replicate 2\")\n   abline(0,1,col=\"#000066\")\n   a<-(x2[!bad2,i]+x2[!bad2,1])/2\n   m<-(x2[!bad2,i]-x2[!bad2,1])\n   smoothScatter(a,m,xlim=c(-17,-11),ylim=c(-10,10),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,main=paste(\"experimental log2 frequencies, replicate 2, d\",time[1],\"-d\",time[i],sep=\"\"))\n   abline(h=0,col=\"#000066\")\n   yl<-lowess(a,m,f=0.2)\n   lines(yl,col=\"red\")\n}\n\n#now plot fitted values\nfor (i in 2:nt) {\n   smoothScatter(fit_x1[!bad1,c(1,i)],xlim=c(-17,-11),ylim=c(-17,-11),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,xlab=paste(\"log2 frequency, d\",time[1],sep=\"\"),ylab=paste(\"log2 frequency, d\",time[i],sep=\"\"),main=\"fitted frequencies, replicate 1\")\n   abline(0,1,col=\"#000066\")\n   a<-(fit_x1[!bad1,i]+fit_x1[!bad1,1])/2\n   m<-(fit_x1[!bad1,i]-fit_x1[!bad1,1])\n   smoothScatter(a,m,xlim=c(-17,-11),ylim=c(-10,10),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,main=paste(\"fitted log2 frequencies, replicate 1, d\",time[1],\"-d\",time[i],sep=\"\"))\n   abline(h=0,col=\"#000066\")\n   yl<-lowess(a,m,f=0.2)\n   lines(yl,col=\"red\")\n}\nfor (i in 2:nt) {\n   smoothScatter(fit_x2[!bad2,c(1,i)],xlim=c(-17,-11),ylim=c(-17,-11),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,xlab=paste(\"log2 frequency, d\",time[1],sep=\"\"),ylab=paste(\"log2 frequency, d\",time[i],sep=\"\"),main=\"fitted frequencies, replicate 2\")\n   abline(0,1,col=\"#000066\")\n   a<-(fit_x2[!bad2,i]+fit_x2[!bad2,1])/2\n   m<-(fit_x2[!bad2,i]-fit_x2[!bad2,1])\n   smoothScatter(a,m,xlim=c(-17,-11),ylim=c(-10,10),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,main=paste(\"fitted log2 frequencies, replicate 1, d\",time[1],\"-d\",time[i],sep=\"\"))\n   abline(h=0,col=\"#000066\")\n   yl<-lowess(a,m,f=0.2)\n   lines(yl,col=\"red\")\n}\n\n#now cross-plots at times 1 2 3..\nfor (i in 1:nt) {\n   smoothScatter(x1[good,i],x2[good,i],xlim=c(-17,-11),ylim=c(-17,-11),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,xlab=paste(\"replicate 1, d\",time[i],sep=\"\"),ylab=paste(\"replicate 2, d\",time[i],sep=\"\"),main=paste(\"comparison of experimental replicates, d\",time[i],sep=\"\"))\nabline(0,1,col=\"#000066\")\n}\nfor (i in 1:nt) {\n   smoothScatter(fit_x1[good,i],fit_x2[good,i],xlim=c(-17,-11),ylim=c(-17,-11),transformation = function(x) {log2(x+1)^.75},pch=16,cex=0.4,xlab=paste(\"replicate 1, d\",time[i],sep=\"\"),ylab=paste(\"replicate 2, d\",time[i],sep=\"\"),main=paste(\"comparison of fitted replicates, d\",time[i],sep=\"\"))\nabline(0,1,col=\"#000066\")\n}\n\n}\n\n\n#----------BEGIN MAIN---------------\npdf(paste(project,\".pdf\",sep=\"\"))\npar(pty=\"s\",mfrow=c(1,1))\n\nX<-read.table(input_filename,sep=\"\\t\",header=TRUE)\n\nsmall<-1e-6\nnt<-length(time) #nt >= 2\nmt<-mean(time)\nvt<-Var(time)\n\n#preliminary preparations of the input data frame\ndata<-data.matrix(X[,6:(5+2*nt)])\ngood<-(X$geneA != X$geneB) #reject any constructs with two 0's\ngoodX<-X[good,] #the 0-0 constructs are gone\nnn<-sum(good) #this many constructs\n\ncpA<-as.character(goodX$probeA)\nix<-grep(\"NonTargeting\",cpA)\ncpA[ix]<-paste(\"0\",cpA[ix],sep=\"\") #this puts NonTargeting probes at the beginning of alphabetically sorted order\n\ncpB<-as.character(goodX$probeB)\nix<-grep(\"NonTargeting\",cpB)\ncpB[ix]<-paste(\"0\",cpB[ix],sep=\"\")\n\npswitch<-cpA>cpB #need to switch?\nphold<-cpA[pswitch]\ncpA[pswitch]<-cpB[pswitch]\ncpB[pswitch]<-phold #cpA and cpB are always in alphabetical order, cpA < cpB\nprobes<-sort(unique(c(cpA,cpB))) #entire probe set in alphabetical order\nnprobes<-length(probes)\n\n\ncgA<-as.character(goodX$geneA)\ncgB<-as.character(goodX$geneB)\ngenes<-sort(unique(cgA)) #should be 74 \"genes\"\nn<-length(genes) # n = 74 if doing it by genes or 222 if doing it by probe\nmm<-n*(n-1)/2\n\ngswitch<-cgA>cgB #need to switch?\nghold<-cgA[gswitch]\ncgA[gswitch]<-cgB[gswitch]\ncgB[gswitch]<-ghold\n\ngA_gB<-paste(cgA,cgB,sep=\"_\")\npA_pB<-paste(cpA,cpB,sep=\"_\")\ngoodX<-data.frame(goodX,cgA,cgB,gA_gB) #now gA_gB is ordered so that gA < gB\n\ngooddata<-data.matrix(goodX[,6:(5+2*nt)])\ngooddata[gooddata==0]<-1 #pseudocounts\nabundance<-apply(gooddata,2,sum)\ny<-t(log2(t(gooddata)/abundance)) #log2 frequencies\n#end data prep \n \nrge<-range(y)\nfor (i in 1:(2*nt)) {\n   h<-hist(y[,i],breaks=seq(rge[1]-0.05,rge[2]+0.05,by=0.05),main=colnames(y)[i],xlab=expression(paste(log[2],\" relative frequency\")),col=\"grey80\",border=FALSE)\n   d<-density(y[,i],bw=0.2)\n   lines(d$x,d$y*sum(h$counts)*0.05,col=\"black\")\n   rug(ab0[i],col=\"red\",lwd=2)\n}\n\ng1names<-matrix(\"\",ncol=n,nrow=n)\ng2names<-matrix(\"\",ncol=n,nrow=n)\nggnames<-matrix(\"\",ncol=n,nrow=n)\nfor (i in 1:(n-1)) {\n   for (j in (i+1):n) {\n      g1names[i,j]<-genes[i]\n      g2names[i,j]<-genes[j]\n      ggnames[i,j]<-paste(genes[i],\"_\",genes[j],sep=\"\")\n      ggnames[j,i]<-ggnames[i,j]\n   }\n}\n\n\n#x1<-y[,c(1,3,5)]\nx1<-y[,seq(1,2*nt,by=2)]\nab1<-ab0[seq(1,2*nt,by=2)]\nbad1<-apply(t(x1)>ab1,2,sum)<2\nsum(bad1)\n\nx2<-y[,seq(2,2*nt,by=2)]\nab2<-ab0[seq(2,2*nt,by=2)]\nbad2<-apply(t(x2)>ab2,2,sum)<2\nsum(bad2)\n\nrownames(x1)<-pA_pB\nrownames(x2)<-pA_pB\n\nresf<-fit_ac_fc(x1,ab1,x2,ab2)\n\na1<-resf[[1]]\na2<-resf[[2]]\nfc<-resf[[3]]\nsdfc<-resf[[4]] #standard error\np_t<-resf[[5]] #raw p-value from t-test\nlfdr_fc<-resf[[6]] #lfdr from p_t (Storey)\npp_fc<-1-lfdr_fc\ndf<-resf[[7]] #degrees of freedom\nallbad<-resf[[8]] #is TRUE when both experiments are bad (at most 1 good value)\n\nplot(fc[!allbad],pp_fc[!allbad],pch=16,cex=0.2,xlab=expression(f[\"c\"]),ylab=\"posterior probability\")\nr<-runif(nn)\nfr<-fc[r<pp_fc]\nrge<-range(fc)\nplotOverlappingHist(fc[!allbad],fr,breaks=seq(rge[1]-.001,rge[2]+0.001,by=0.001),xlab=expression(f[\"c\"]),ylab=\"Frequency\")\n\n\n\n\nnames(fc)<-pA_pB\nnames(pp_fc)<-pA_pB\nnames(sdfc)<-pA_pB\nhist(2^a1,breaks=1000,xlab=\"relative abundance\",main=\"replicate 1, time 0\")\n#e1<-ecdf(2^a1)\n#plot(e1,xlab=\"relative abundance\",ylab=\"ecdf\",main=\"replicate 1, time 0\")\nhist(2^a2,breaks=1000,xlab=\"relative abundance\",main=\"replicate 2, time 0\")\n#e2<-ecdf(2^a2)\n#plot(e2,xlab=\"relative abundance\",ylab=\"ecdf\",main=\"replicate 2, time 0\")\n\nu1<-rep(0,nn)\nnames(u1)<-pA_pB\nu1[!allbad]<-1  #all other weights set to 1\n\n\n\n\n\n\nfc0<-fc\nfc_0<-matrix(0,nrow=nprobes,ncol=nprobes)\nsdfc_0<-matrix(0,nrow=nprobes,ncol=nprobes)\nw0_0<-matrix(0,nrow=nprobes,ncol=nprobes)\npp_0<-matrix(0,nrow=nprobes,ncol=nprobes)\nrownames(fc_0)<-probes\ncolnames(fc_0)<-probes\nrownames(sdfc_0)<-probes\ncolnames(sdfc_0)<-probes\nrownames(w0_0)<-probes\ncolnames(w0_0)<-probes\nrownames(pp_0)<-probes\ncolnames(pp_0)<-probes\nfor (i in 1:(n-1)) {\n   for (k in 1:3) {\n      iprobe<-(i-1)*3+k\n      iprobe_name<-probes[iprobe]\n      for (j in (i+1):n) {\n         for (l in 1:3) {\n            jprobe<-(j-1)*3+l\n            jprobe_name<-probes[jprobe]\n            construct<-paste(iprobe_name,\"_\",jprobe_name,sep=\"\")\n            w0_0[iprobe_name,jprobe_name]<-u1[construct] #initial weights. non-existent pairs will have w0=0\n            pp_0[iprobe_name,jprobe_name]<-pp_fc[construct] #initial weights. non-existent pairs will have w0=0\n            fc_0[iprobe_name,jprobe_name]<-fc0[construct]\n            sdfc_0[iprobe_name,jprobe_name]<-sdfc[construct]\n         }\n      }\n   }\n}\nw0_0<-w0_0+t(w0_0) #make symmetric\nfc_0<-fc_0+t(fc_0)\npp_0<-pp_0+t(pp_0)\n\n#robust fitting\nres2<-irls(fc_0,w0_0,probes,ag=2,tol=1e-3,maxit=50)\n\nfp<-res2[[1]] #these are probe fitnesses fp\n#since fp is determined up to an additive constant, set the constant by \n#requiring that mean(fp[1:3]) = 0 (the null probes have zero fitness\nmnull<-mean(fp[1:3])\n\nfp<-fp-mnull\nfc<-fc-mnull*2\n\n\n\n#now shift a's according to the relation ac<-mx-mt*fc\n#end removing freedom\n#a, fc, and fp are fully set\n\nrank_p<-rep(0,nprobes)\nnames(rank_p)<-probes\n#find best probes\nfp12<-fp\ni<-1 #do null construct\nrank_p[(i-1)*3+1:3]<-rank(abs(fp12[(i-1)*3+1:3])) #looking for the worst\nfor (i in 2:n) {\n   rank_p[(i-1)*3+1:3]<-rank(-abs(fp12[(i-1)*3+1:3])) #looking for the best\n}\np_rank<-3-rank_p\nwpi1<-matrix(0,nrow=nprobes,ncol=nprobes)\nfor (i in 1:nprobes) {\n   for (j in 1:nprobes) {\n      wpi1[i,j]<-(rank_p[i]-3)*(rank_p[j]-3)\n   }\n}\n\nf<-rep(0,n)\nnames(f)<-genes\nfor (i in 1:n) {\n   w1<-(rank_p[(i-1)*3+1:3]-3)^2 #ansatz for weights\n   f[i]<-sum(w1*fp[(i-1)*3+1:3])/sum(w1) #weighted mean\n\n}\nfmean<-f\n\npi1<-res2[[3]] #raw pi-scores per construct\n\nmean_pi1<-matrix(0,nrow=n,ncol=n)\nfor (i in 1:(n-1)) {\n   ixi<-3*(i-1)+1:3\n   for (j in (i+1):n) {\n      ixj<-3*(j-1)+1:3\n      expressed1<-w0_0[ixi,ixj]>0 #define expressed probe pairs\n      local_w1<-wpi1[ixi,ixj]/sum(wpi1[ixi,ixj][expressed1])*sum(expressed1)\n\n      mean_pi1[i,j]<-sum((pi1[ixi,ixj]*wpi1[ixi,ixj])[expressed1])/max(small,sum(wpi1[ixi,ixj][expressed1]))\n   }\n}\nuutri<-upper.tri(mean_pi1)\nuutri[1,]<-FALSE #remove top line, 0\nzi1<-mean_pi1[uutri]\nzi<-zi1\nnpi<-length(zi1)\n\n\n\n\nmmm<-length(fp)\npi_iter<-matrix(0,nrow=npi,ncol=niter)\nfp_iter<-matrix(0,nrow=mmm,ncol=niter)\nf_iter<-matrix(0,nrow=n,ncol=niter)\nutri<-upper.tri(fc_0)\nntri<-sum(utri)\nppi_iter<-matrix(0,nrow=ntri,ncol=niter)\n\nfor (iter in 1:niter) {\n   cat(\"\\n\",iter,\"\\n\")\n   \n   fc_1<-matrix(0,nrow=nprobes,ncol=nprobes)\n   fc0<-fc_0[utri]+rnorm(ntri,sd=sdfc_0[utri])\n#  fc0<-fc_0[utri]\n   pp0<-pp_0[utri]\n   draw<-ifelse(runif(ntri)<pp0,1,0)\n   fc_1[utri]<-fc0*draw\n   fc_1<-fc_1+t(fc_1)\n   \n   #robust fitting\n   res2<-irls(fc_1,w0_0,probes,ag=2,tol=1e-3,maxit=50)\n\n   fp0<-res2[[1]] #these are probe fitnesses fp\n\n   #since fp is determined up to an additive constant, set the constant by \n   #requiring that mean(fp[1:3]) = 0 (the null probes have zero fitness\n\n\n\n   mnull<-mean(fp0[1:3])\n   fp0<-fp0-mnull\n   \n   for (i in 1:n) {\n      w1<-(rank_p[(i-1)*3+1:3]-3)^2 #ansatz for weights\n      f_iter[i,iter]<-sum(w1*fp0[(i-1)*3+1:3])/sum(w1) #weighted mean\n   }\n   \n   pi1<-res2[[3]] #raw pi-scores per construct\n   pi_scrambled<-pi1\n#  upi1<-pi1[utri]\n#  ppi_iter[,iter]<-upi1\n#  upi1<-sample(upi1) #BOOM\n#  pi_scrambled<-matrix(0,nrow=nprobes,ncol=nprobes)\n#  pi_scrambled[utri]<-upi1\n#  pi_scrambled<-pi_scrambled+t(pi_scrambled)\n   \n   mean_pi1<-matrix(0,nrow=n,ncol=n)\n   for (i in 1:(n-1)) {\n      ixi<-3*(i-1)+1:3\n      for (j in (i+1):n) {\n         ixj<-3*(j-1)+1:3\n         expressed1<-w0_0[ixi,ixj]>0 #define expressed probe pairs\n         local_w1<-wpi1[ixi,ixj]/sum(wpi1[ixi,ixj][expressed1])*sum(expressed1)\n   \n         mean_pi1[i,j]<-sum((pi_scrambled[ixi,ixj]*wpi1[ixi,ixj])[expressed1])/max(small,sum(wpi1[ixi,ixj][expressed1]))\n      }\n   }\n   zi1<-mean_pi1[uutri]\n   \n   pi_iter[,iter]<-zi1\n   fp_iter[,iter]<-fp0\n}\n\nf_mean<-apply(f_iter,1,mean)\nf_sd<-apply(f_iter,1,sd)\n#plot(f_mean,f_sd,pch=\".\",cex=2)\n\nfp_mean<-apply(fp_iter,1,mean)\nfp_sd<-apply(fp_iter,1,sd)\n#plot(fp_mean,fp_sd)\n\n#pi_mean<-apply(pi_iter,1,mean)\npi_mean<-apply(pi_iter,1,mean)\npi_sd<-apply(pi_iter,1,sd)\n\n\npi_iter_null<-pi_iter-pi_mean\n\n\npi_null<-c(pi_iter_null,-pi_iter_null)\nenull<-ecdf(pi_null)\nemean<-ecdf(pi_mean)\n\nrge<-range(pi_mean)\nh<-hist(pi_mean,breaks=seq(rge[1]-0.002,rge[2]+0.002,by=0.002),main=\"\",xlab=expression(pi[\"gg'\"]),col=\"grey80\",border=FALSE,probability=TRUE)\n   d<-density(pi_null,bw=0.002)\n   lines(d,col=\"black\")\n   rug(pi_mean)\nbox()\nfdr_left<-pmin(1,enull(pi_mean)/emean(pi_mean))\nfdr_right<-pmin(1,(enull(-pi_mean))/(1-emean(pi_mean)))\nplot(pi_mean,fdr_left,ylim=c(0,1),xlab=expression(pi[\"gg'\"]),ylab=\"FDR, left\") #left tail test\nplot(pi_mean,fdr_right,ylim=c(0,1),xlab=expression(pi[\"gg'\"]),ylab=\"FDR, right\") #right tail test\n\nz<-pi_mean/sd(pi_mean)\n\n\npi_iter_null<-pi_iter-pi_mean\nabspi<-abs(pi_mean)\nPP<-apply(abs(pi_iter_null)<abspi,1,mean)\n\n#oPP<-order(abspi,decreasing=TRUE)\noPP<-order(z)\n\n#who are these gene pairs?\nnames_of_g1<-g1names[uutri]\nfg1<-f[names_of_g1]\nnames_of_g2<-g2names[uutri]\nfg2<-f[names_of_g2]\nfg12<-fg1+fg2\nnames_of_gg<-ggnames[uutri]\n\n#res<-data.frame(names_of_gg,names_of_g1,fg1,names_of_g2,fg2,fg12,zi,pi_sd,pi_pp)\n\nres<-data.frame(names_of_gg,names_of_g1,fg1,names_of_g2,fg2,fg12,pi_mean,pi_sd,PP,abspi,fdr_left,fdr_right,z)\ncolnames(res)<-c(\"gene_gene\",\"geneA\",\"fA\",\"geneB\",\"fB\",\"fA+fB\",\"pi\",\"sd\",\"PP\",\"abs pi\",\"FDR left\",\"FDR right\",\"z\")\nwrite.table(res[oPP,],file=paste(project,\"_pi.txt\",sep=\"\"),sep=\"\\t\",row.names=FALSE,quote=FALSE)\n\n\n\n\nplot_fit(x1,a1,fc,ab1,x2,a2,fc,ab2,minfc=0.10)\n\n\nresp<-data.frame(pA_pB,fc,sdfc)\nwrite.table(resp,file=paste(project,\"_fc.txt\",sep=\"\"),sep=\"\\t\",row.names=FALSE,quote=FALSE)\n\nsum(bad1 & bad2)\ngood<-!bad1 & !bad2\n\n\nrge<-range(fc)\nhh<-hist(fc[!allbad],breaks=seq(rge[1]-0.005,rge[2]+0.005,by=0.005),main=\"construct fitness\",col=\"grey80\",border=FALSE,xlab=expression(f[\"c\"]))\nd<-density(fc[!allbad],bw=0.01)\nlines(d$x,d$y*sum(hh$counts)*0.005,col=\"black\")\n\nrug(fc[!allbad])\nabline(h=0)\n\n\nplot_scatterplots()\n\nrge<-range(fp)\nfor (i in 1:n) {\n   plot(fp,fp,xlim=rge,ylim=rge,main=genes[i])\n   abline(h=0,v=0)\n   points(fp[(i-1)*3+1:3],fp[(i-1)*3+1:3],pch=16,col=\"red\")\n}\n\n\nresp<-data.frame(probes,p_rank)\nwrite.table(resp,file=paste(project,\"_p.txt\",sep=\"\"),sep=\"\\t\",row.names=FALSE,quote=FALSE)\n\n\nresy<-data.frame(genes,f,f_sd)\ncolnames(resy)<-c(\"gene\",\"f\",\"sd\")\nwrite.table(resy[-1,],file=paste(project,\"_f.txt\",sep=\"\"),sep=\"\\t\",row.names=FALSE,quote=FALSE)\n\nrge<-range(f)*1.1 #with some margin\nplot(f[-1],f[-1],pch=16,cex=0.6,col=\"blue\",xlim=rge,ylim=rge,xlab=expression(f[\"g\"]),ylab=expression(f[\"g\"]),main=\"single-gene fitness\")\nabline(v=0,h=0,col=\"#000066\")\ntext(f[-1],f[-1],cex=0.6,labels=genes[-1],pos=((rank(f[-1]) %% 2)+1)*2,offset=0.2)\n\n\n\ndev.off()\n",
    "created" : 1472598620157.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "936608059",
    "id" : "200FCF9F",
    "lastKnownWriteTime" : 1472598619,
    "last_content_update" : 1472598619,
    "path" : "/private/var/folders/hn/rpn4rhms41v939mg20d7w0dh0000gn/T/com.microsoft.Outlook/Outlook Temp/analyze_dual-crispr_NA_combined_simple-null-w-lfdr[5].R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}